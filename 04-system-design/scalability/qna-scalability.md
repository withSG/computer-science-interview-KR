# 확장성 면접 질문 & 답변

## 사용 방법
1. 질문을 먼저 읽고 스스로 답변해보세요
2. 답변을 확인하고 부족한 부분을 학습하세요
3. ⭐ 표시는 빈출 질문입니다

---

## Q1. 수평 확장(Horizontal Scaling)과 수직 확장(Vertical Scaling)의 차이는? ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변

| 구분 | 수직 확장 (Scale Up) | 수평 확장 (Scale Out) |
|------|---------------------|----------------------|
| 방식 | 더 강력한 서버로 교체 | 서버 대수 추가 |
| 비용 | 고성능 장비 = 비쌈 | 저렴한 서버 여러 대 |
| 한계 | 하드웨어 한계 존재 | 이론상 무제한 |
| 복잡성 | 단순 | 분산 시스템 복잡성 |
| 장애 | 단일 장애점 (SPOF) | 고가용성 |

### 수직 확장 (Vertical Scaling)

```
┌──────────────┐      ┌──────────────────┐
│  서버 1대    │  →   │    더 강력한 서버   │
│  CPU 4코어   │      │    CPU 32코어     │
│  RAM 16GB   │      │    RAM 256GB     │
└──────────────┘      └──────────────────┘
```

**장점**: 구현 간단, 데이터 일관성 유지
**단점**: 비용 급증, 하드웨어 한계, SPOF

### 수평 확장 (Horizontal Scaling)

```
┌──────────────┐      ┌──────────────┐
│   서버 1대   │      │    서버 N대    │
│             │  →   │  ┌───┬───┬───┐ │
│             │      │  │ S1│ S2│ S3│ │
└──────────────┘      │  └───┴───┴───┘ │
                      └──────────────┘
```

**장점**: 이론상 무제한, 고가용성, 비용 효율적
**단점**: 복잡성 증가, 데이터 동기화 필요

### 수평 확장 시 고려사항

```
1. 상태 관리
   - Stateless 서버 설계
   - 세션 외부 저장 (Redis)

2. 데이터 일관성
   - DB 복제/샤딩
   - 캐시 동기화

3. 로드 밸런싱
   - 트래픽 분산

4. 서비스 디스커버리
   - 동적 서버 추가/제거
```

### 면접관이 주목하는 포인트
- 각 방식의 트레이드오프
- 수평 확장 시 고려사항

</details>

---

## Q2. 로드 밸런서(Load Balancer)의 역할과 알고리즘은? ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
로드 밸런서는 **들어오는 트래픽을 여러 서버에 분산**하여 가용성과 성능을 향상시킵니다.

### 로드 밸런싱 알고리즘

| 알고리즘 | 설명 | 사용 사례 |
|---------|------|----------|
| Round Robin | 순차적 분배 | 동일 스펙 서버 |
| Weighted Round Robin | 가중치 기반 분배 | 다른 스펙 서버 |
| Least Connections | 연결 수 적은 서버 | 연결 시간 불균등 |
| IP Hash | 클라이언트 IP 기반 | 세션 유지 필요 |
| Least Response Time | 응답 빠른 서버 | 성능 최적화 |

### 로드 밸런서 계층

```
L4 (Transport Layer)
- TCP/UDP 수준
- IP, Port 기반 분배
- 빠름, 단순

L7 (Application Layer)
- HTTP 수준
- URL, 헤더, 쿠키 기반 분배
- 유연함, 스마트 라우팅
```

### 로드 밸런서 구성

```
                    ┌─────────────────┐
                    │  Load Balancer  │
                    │    (Active)     │
                    └────────┬────────┘
                             │
                    ┌────────┼────────┐
                    │        │        │
              ┌─────▼─┐  ┌───▼───┐  ┌─▼─────┐
              │Server1│  │Server2│  │Server3│
              └───────┘  └───────┘  └───────┘
```

### Health Check

```
로드 밸런서가 서버 상태 주기적 확인

- Passive: 실패 응답 감지
- Active: 주기적 요청 (ping, HTTP)

Health Check 실패 → 해당 서버로 트래픽 전송 중단
```

### Sticky Session

```
같은 클라이언트를 같은 서버로 라우팅

방법:
1. 쿠키 기반: LB가 세션 쿠키 삽입
2. IP 기반: 클라이언트 IP로 서버 결정

문제점:
- 서버 장애 시 세션 손실
- 부하 불균형 가능
→ 외부 세션 저장소 권장 (Redis)
```

### 면접관이 주목하는 포인트
- 알고리즘 선택 기준
- Health Check의 중요성

</details>

---

## Q3. 데이터베이스 샤딩(Sharding)이란? ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
샤딩은 **데이터를 여러 데이터베이스에 분산 저장**하는 수평 분할 기법입니다.

### 샤딩 vs 파티셔닝

| 구분 | 샤딩 | 파티셔닝 |
|------|------|---------|
| 위치 | 여러 물리 서버 | 단일 서버 내부 |
| 목적 | 확장성 | 관리/성능 |

### 샤딩 전략

**1. Range Sharding (범위)**
```
Shard 1: user_id 1-1000000
Shard 2: user_id 1000001-2000000
Shard 3: user_id 2000001-3000000

장점: 범위 쿼리 효율적
단점: 핫스팟 발생 가능 (최근 가입자 집중)
```

**2. Hash Sharding (해시)**
```
shard_key = hash(user_id) % num_shards

장점: 균등 분배
단점: 범위 쿼리 비효율, 리샤딩 어려움
```

**3. Directory-based Sharding (디렉토리)**
```
별도의 매핑 테이블 관리

장점: 유연한 매핑
단점: 단일 장애점, 조회 오버헤드
```

### 샤딩의 문제점

```
1. Cross-shard 쿼리
   - 여러 샤드 조인 어려움
   - 애플리케이션에서 처리

2. 리샤딩
   - 샤드 추가/제거 복잡
   - Consistent Hashing으로 완화

3. 핫스팟
   - 특정 샤드에 트래픽 집중
   - 샤딩 키 설계 중요

4. 트랜잭션
   - 분산 트랜잭션 필요
   - 2PC, Saga 패턴
```

### Consistent Hashing

```
리샤딩 시 최소한의 데이터만 이동

기존 해시: 서버 추가 시 전체 재배치
Consistent Hash: 인접 노드에만 영향

┌────────────────────────┐
│        Hash Ring       │
│    ┌───┐     ┌───┐    │
│    │ A │─────│ B │    │
│    └───┘     └───┘    │
│      \       /        │
│       \     /         │
│        ┌───┐          │
│        │ C │          │
│        └───┘          │
└────────────────────────┘
```

### 면접관이 주목하는 포인트
- 샤딩 전략 선택 기준
- 샤딩의 문제점과 해결책

</details>

---

## Q4. CAP 정리(CAP Theorem)란? ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
분산 시스템에서 **Consistency, Availability, Partition Tolerance 중 2가지만 동시에 만족**할 수 있다는 정리입니다.

### CAP 요소

| 요소 | 설명 |
|------|------|
| Consistency (일관성) | 모든 노드가 같은 데이터 |
| Availability (가용성) | 모든 요청에 응답 |
| Partition Tolerance (분할 내성) | 네트워크 분할에도 동작 |

### CAP 조합

```
분산 시스템에서 P(Partition Tolerance)는 필수
→ 실제로는 CP vs AP 선택

CP (Consistency + Partition Tolerance)
- 일관성 우선
- 네트워크 분할 시 일부 요청 거부
- 예: MongoDB, HBase, Redis Cluster

AP (Availability + Partition Tolerance)
- 가용성 우선
- 네트워크 분할 시에도 응답 (오래된 데이터 가능)
- 예: Cassandra, DynamoDB, CouchDB
```

### PACELC 확장

```
네트워크 분할(P) 시 A vs C 선택
그 외(E, Else) 상황에서 L(Latency) vs C 선택

PA/EL: 항상 가용성과 지연시간 우선 (Cassandra)
PC/EC: 항상 일관성 우선 (MongoDB)
PA/EC: 평소엔 일관성, 분할 시 가용성
```

### 면접관이 주목하는 포인트
- CAP의 실제 의미 이해
- 실제 시스템의 CAP 선택 사례

</details>

---

## Q5. 데이터베이스 복제(Replication) 전략은? ⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
복제는 **데이터를 여러 노드에 복사**하여 가용성과 읽기 성능을 향상시킵니다.

### 복제 방식

**1. Master-Slave (Primary-Replica)**
```
┌────────────┐
│   Master   │ ← 쓰기 전담
└─────┬──────┘
      │ 복제
┌─────┼──────┐
│     │      │
▼     ▼      ▼
Slave Slave Slave ← 읽기 분산
```

**장점**: 읽기 확장, 백업
**단점**: 쓰기 병목, 복제 지연, Master 장애 시 failover

**2. Master-Master (Multi-Master)**
```
┌────────────┐     ┌────────────┐
│  Master 1  │ ←── │  Master 2  │
│            │ ──► │            │
└────────────┘     └────────────┘
    읽기/쓰기          읽기/쓰기
```

**장점**: 쓰기 분산, 고가용성
**단점**: 충돌 해결 복잡, 일관성 문제

### 동기 vs 비동기 복제

| 구분 | 동기 복제 | 비동기 복제 |
|------|----------|------------|
| 일관성 | 강함 | 약함 (지연) |
| 성능 | 느림 | 빠름 |
| 가용성 | Replica 장애 시 영향 | 영향 없음 |

### Eventual Consistency

```
비동기 복제에서의 최종 일관성

모든 업데이트가 전파되면 결국 모든 노드가 같은 상태

시간 t1: Master = v2, Replica = v1
시간 t2: Master = v2, Replica = v2 (일치)
```

### 면접관이 주목하는 포인트
- 복제 방식의 트레이드오프
- 복제 지연 문제와 해결책

</details>

---

## Q6. 마이크로서비스와 모놀리식의 차이는? ⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변

| 구분 | 모놀리식 | 마이크로서비스 |
|------|---------|---------------|
| 구조 | 단일 배포 단위 | 독립 서비스들 |
| 배포 | 전체 배포 | 서비스별 배포 |
| 확장 | 전체 확장 | 서비스별 확장 |
| 기술 | 단일 스택 | 다양한 스택 가능 |
| 복잡성 | 코드 복잡 | 운영 복잡 |

### 모놀리식

```
┌────────────────────────────────┐
│        Monolithic App          │
│  ┌──────┬──────┬──────┬─────┐ │
│  │ User │ Order│ Product│Pay │ │
│  └──────┴──────┴──────┴─────┘ │
│           Single DB            │
└────────────────────────────────┘
```

### 마이크로서비스

```
┌─────────┐  ┌─────────┐  ┌─────────┐
│  User   │  │  Order  │  │ Product │
│ Service │  │ Service │  │ Service │
│   DB    │  │   DB    │  │   DB    │
└────┬────┘  └────┬────┘  └────┬────┘
     │            │            │
     └────────────┼────────────┘
                  │
            Message Queue / API Gateway
```

### 마이크로서비스 장단점

**장점**:
- 독립적 배포/확장
- 기술 선택 자유
- 장애 격리
- 팀 독립성

**단점**:
- 운영 복잡성 (k8s, 모니터링)
- 분산 트랜잭션
- 네트워크 지연
- 데이터 일관성

### 면접관이 주목하는 포인트
- 각 아키텍처의 적합한 상황
- 마이크로서비스 도입 시 고려사항

</details>

---

## 학습 체크리스트

- [ ] 수평/수직 확장 차이 설명 가능
- [ ] 로드 밸런싱 알고리즘 3가지 이상 알기
- [ ] 샤딩 전략과 문제점 이해
- [ ] CAP 정리 설명 가능
- [ ] 복제 전략과 트레이드오프 알기
