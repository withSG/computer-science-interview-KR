# 소프트웨어 공학 면접 질문 & 답변

## 사용 방법
1. 질문을 먼저 읽고 스스로 답변해보세요
2. 답변을 확인하고 부족한 부분을 학습하세요
3. ⭐ 표시는 빈출 질문입니다

---

## Q1. 애자일(Agile) 방법론이란? ⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
애자일은 **짧은 주기의 반복적 개발**을 통해 변화에 빠르게 대응하는 개발 방법론입니다.

### 애자일 원칙

```
- 프로세스보다 개인과 상호작용
- 문서보다 작동하는 소프트웨어
- 계약보다 고객 협력
- 계획보다 변화 대응
```

### Scrum vs Kanban

| 구분 | Scrum | Kanban |
|------|-------|--------|
| 반복 | 스프린트 (2-4주) | 연속적 |
| 역할 | PO, SM, Team | 없음 |
| 변경 | 스프린트 중 고정 | 언제든 가능 |
| 측정 | 번다운 차트 | 리드 타임 |

### Scrum 이벤트

```
- Sprint Planning: 작업 계획
- Daily Standup: 15분 공유
- Sprint Review: 결과 데모
- Retrospective: 회고
```

</details>

---

## Q2. TDD(Test-Driven Development)란? ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
TDD는 **테스트를 먼저 작성하고 코드를 구현**하는 개발 방법입니다.

### TDD 사이클 (Red-Green-Refactor)

```
1. Red: 실패하는 테스트 작성
2. Green: 테스트 통과하는 최소 코드 작성
3. Refactor: 코드 개선 (테스트 유지)
```

### 예시

```python
# 1. Red - 실패하는 테스트
def test_add():
    assert add(1, 2) == 3  # NameError: add 없음

# 2. Green - 통과하는 코드
def add(a, b):
    return a + b

# 3. Refactor - 필요시 개선
```

### TDD 장점

- 설계 개선 (테스트 가능한 코드)
- 회귀 방지
- 문서화 역할
- 자신감 있는 리팩토링

### 면접관이 주목하는 포인트
- TDD 실제 경험
- 장단점 인식

</details>

---

## Q3. 테스트 종류에는 어떤 것이 있나요? ⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변

### 테스트 피라미드

```
        /\
       /  \     E2E Test (적음)
      /----\
     /      \   Integration Test
    /--------\
   /          \  Unit Test (많음)
  --------------
```

### 테스트 종류

| 종류 | 범위 | 속도 | 비용 |
|------|------|------|------|
| Unit | 함수/클래스 | 빠름 | 낮음 |
| Integration | 모듈 간 연동 | 중간 | 중간 |
| E2E | 전체 시스템 | 느림 | 높음 |

### 예시

```python
# Unit Test
def test_calculate_total():
    assert calculate_total([10, 20]) == 30

# Integration Test
def test_user_creation():
    user = UserService.create({"name": "test"})
    assert UserRepository.find(user.id) is not None

# E2E Test
def test_checkout_flow():
    driver.get("/shop")
    driver.find_element(By.ID, "add-to-cart").click()
    driver.find_element(By.ID, "checkout").click()
    assert "주문 완료" in driver.page_source
```

</details>

---

## Q4. CI/CD란 무엇인가요? ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변

| 용어 | 설명 |
|------|------|
| CI (Continuous Integration) | 코드 변경을 자주 통합, 자동 빌드/테스트 |
| CD (Continuous Delivery) | 언제든 배포 가능한 상태 유지 |
| CD (Continuous Deployment) | 자동 프로덕션 배포 |

### CI/CD 파이프라인 예시

```yaml
# GitHub Actions
name: CI/CD

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: npm install
      - name: Run tests
        run: npm test
      - name: Build
        run: npm run build
      - name: Deploy
        if: github.ref == 'refs/heads/main'
        run: ./deploy.sh
```

### CI/CD 이점

```
- 빠른 피드백
- 버그 조기 발견
- 배포 자동화
- 일관된 품질
```

</details>

---

## Q5. 코드 리뷰의 목적은? ⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
코드 리뷰는 **코드 품질 향상과 지식 공유**를 위한 협업 프로세스입니다.

### 리뷰 포인트

```
- 로직 정확성
- 코드 스타일 일관성
- 성능 문제
- 보안 취약점
- 테스트 커버리지
- 가독성
```

### 좋은 리뷰어

```
- 구체적인 피드백 제공
- 질문 형태로 제안
- 긍정적인 부분도 언급
- 적시에 리뷰
```

</details>

---

## Q6. KISS 원칙이란? ⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
KISS(Keep It Simple, Stupid)는 **가능한 한 단순하게 설계**해야 한다는 소프트웨어 원칙입니다.

### 핵심 개념
```
복잡한 해결책보다 단순한 해결책이 더 좋다
- 유지보수 용이
- 버그 감소
- 이해하기 쉬움
```

### KISS 위반 예시
```python
# 복잡한 코드 (KISS 위반)
def is_even(n):
    return n % 2 == 0 if n >= 0 else (n * -1) % 2 == 0

# 단순한 코드 (KISS 준수)
def is_even(n):
    return n % 2 == 0
```

### 관련 원칙들

| 원칙 | 의미 |
|------|------|
| KISS | 단순하게 유지 |
| YAGNI | 필요없는 것은 만들지 말기 |
| DRY | 반복하지 않기 |
| SOLID | 객체지향 설계 원칙 |

### 면접관이 주목하는 포인트
- 과도한 추상화/설계의 문제점 인식
- 언제 단순함을 선택하는지

</details>

---

## Q7. 브룩스의 법칙(Brooks' Law)이란? ⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
> "지연되고 있는 프로젝트에 인력을 추가하면 더 늦어진다"
> — Fred Brooks, 《The Mythical Man-Month》

### 이유

**1. 온보딩 비용**
```
새로운 인력의 학습 시간
- 코드베이스 이해
- 도메인 지식 습득
- 팀 프로세스 적응
```

**2. 커뮤니케이션 오버헤드**
```
인원 수(n)에 따른 커뮤니케이션 채널: n(n-1)/2

4명: 6채널
5명: 10채널
6명: 15채널
```

**3. 작업 분할 한계**
- 모든 작업이 병렬화 가능하지 않음
- 순차적 의존성 존재

### 해결 방안
- 초기 단계에서 적절한 인력 투입
- 작은 자율적 팀 구성
- 명확한 인터페이스와 책임 분리

### 면접관이 주목하는 포인트
- 소프트웨어 프로젝트 관리 이해
- 팀 규모와 생산성 관계

</details>

---

## Q8. 테스트 종류(시스템 테스트, 인수 테스트)를 설명해주세요. ⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변

| 테스트 | 수행 주체 | 목적 | 시점 |
|--------|----------|------|------|
| 단위 테스트 | 개발자 | 함수/클래스 검증 | 개발 중 |
| 통합 테스트 | 개발자/QA | 모듈 연동 검증 | 개발 후 |
| 시스템 테스트 | QA | 전체 시스템 검증 | 통합 후 |
| 인수 테스트 | 고객/사용자 | 요구사항 충족 확인 | 배포 전 |

### 시스템 테스트 (System Testing)
```
전체 시스템이 요구사항대로 동작하는지 검증
- 기능 테스트
- 성능 테스트
- 보안 테스트
- 스트레스 테스트
```

### 인수 테스트 (Acceptance Testing)
```
고객 관점에서 비즈니스 요구사항 충족 확인
- 알파 테스트: 개발사 내부
- 베타 테스트: 실제 사용자
- UAT: 최종 사용자 승인
```

### 인수 테스트 예시 (Gherkin)
```gherkin
Feature: 사용자 로그인

Scenario: 올바른 자격증명으로 로그인
  Given 사용자가 로그인 페이지에 있다
  When 올바른 이메일과 비밀번호를 입력한다
  And 로그인 버튼을 클릭한다
  Then 대시보드 페이지로 이동한다
```

### V-모델
```
요구사항 분석 ←――――――――――→ 인수 테스트
      ↓                      ↑
   시스템 설계 ←―――――――→ 시스템 테스트
        ↓                  ↑
    상세 설계 ←――――――→ 통합 테스트
          ↓              ↑
        코딩 ←――――→ 단위 테스트
```

### 면접관이 주목하는 포인트
- 각 테스트 단계의 목적 차이
- 실무에서의 테스트 전략

</details>

---

## Q9. 테스트 코드를 작성해야 하는 이유는? ⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
테스트 코드는 **코드의 정확성을 보장하고, 변경에 대한 자신감을 주며, 문서 역할**을 합니다.

### 테스트 코드의 이점

| 이점 | 설명 |
|------|------|
| 회귀 방지 | 기존 기능이 깨지지 않음을 보장 |
| 리팩토링 안정성 | 코드 변경 후 검증 자동화 |
| 문서화 | 코드 사용법을 예제로 제공 |
| 설계 개선 | 테스트하기 쉬운 구조로 유도 |
| 디버깅 시간 단축 | 문제 발생 시 빠른 원인 파악 |

### 테스트가 없는 경우의 문제점

```
❌ 수동 테스트에 의존 → 시간 소모, 휴먼 에러
❌ 리팩토링 두려움 → 기술 부채 증가
❌ 배포 불안감 → 릴리즈 지연
❌ 버그 재발 → 같은 문제 반복
```

### 테스트 코드의 비용 vs 가치

```
초기 비용: 테스트 작성 시간
장기 가치:
  - 수동 테스트 시간 절약
  - 버그 수정 비용 감소
  - 유지보수 비용 절감

→ 프로젝트가 길어질수록 테스트의 ROI가 증가
```

### 테스트 작성 우선순위

```
1. 핵심 비즈니스 로직
2. 버그가 자주 발생하는 코드
3. 복잡한 알고리즘
4. 외부 시스템 연동부
5. 자주 변경되는 코드
```

### 면접관이 주목하는 포인트
- 테스트 작성 경험과 그 효과
- 테스트 작성을 어렵게 만드는 코드 패턴 인식

### 꼬리 질문 대비
- "테스트 코드 작성이 개발 속도를 늦추지 않나요?"
  → 초기에는 시간이 더 걸리지만, 버그 수정 및 수동 테스트 시간을 줄여 전체적으로는 빨라짐

</details>

---

## Q10. 테스트 커버리지란 무엇이며 어느 정도가 적절한가요? ⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
테스트 커버리지는 **테스트가 코드의 얼마나 많은 부분을 실행하는지 측정하는 지표**입니다. 100%가 목표가 아니라, **핵심 로직에 대한 의미 있는 테스트**가 중요합니다.

### 커버리지 종류

| 종류 | 설명 | 예시 |
|------|------|------|
| Line Coverage | 실행된 코드 라인 비율 | 10줄 중 8줄 실행 = 80% |
| Branch Coverage | 분기(if/else) 실행 비율 | 4개 분기 중 3개 실행 = 75% |
| Function Coverage | 호출된 함수 비율 | 5개 함수 중 4개 호출 = 80% |
| Statement Coverage | 실행된 문장 비율 | 모든 구문 실행 여부 |

### 커버리지 측정 예시

```java
// 테스트 대상 코드
public int divide(int a, int b) {
    if (b == 0) {           // 분기 1
        throw new IllegalArgumentException();
    }
    return a / b;           // 분기 2
}

// 테스트 코드 (분기 2만 테스트)
@Test
void testDivide() {
    assertEquals(2, divide(4, 2));
}
// Line: 66%, Branch: 50%
```

### 적정 커버리지 수준

```
일반적인 권장: 70-80%
핵심 비즈니스 로직: 90% 이상
유틸리티/인프라 코드: 60-70%

⚠️ 주의: 높은 커버리지 ≠ 좋은 테스트
```

### 커버리지의 한계

```
✗ 테스트 품질을 보장하지 않음
✗ 모든 엣지 케이스 검증 불가
✗ 비즈니스 로직 정확성과 무관할 수 있음

예: 아래 테스트는 100% 커버리지지만 무의미
@Test
void badTest() {
    calculate(1, 2);  // assertion 없음
}
```

### 커버리지보다 중요한 것

```
1. 의미 있는 assertion
2. 경계값 테스트
3. 실패 케이스 테스트
4. 비즈니스 시나리오 커버
5. 버그 발생 시 회귀 테스트 추가
```

### 면접관이 주목하는 포인트
- 커버리지 수치에 집착하지 않는 균형잡힌 시각
- 의미 있는 테스트의 기준 이해

### 꼬리 질문 대비
- "100% 커버리지를 목표로 해야 하나요?"
  → 비용 대비 효과를 고려해야 함. getter/setter, 간단한 위임 코드까지 테스트하는 것은 비효율적

</details>

---

## 학습 체크리스트

- [ ] 애자일 원칙과 Scrum 이해
- [ ] TDD 사이클 설명 가능
- [ ] 테스트 피라미드 이해
- [ ] CI/CD 개념과 이점 알기
- [ ] 코드 리뷰 목적 설명 가능
- [ ] KISS 원칙과 관련 원칙들 설명 가능
- [ ] 브룩스의 법칙 이해
- [ ] 시스템 테스트와 인수 테스트 구분 가능
- [ ] 테스트 코드 작성 이유 설명 가능
- [ ] 테스트 커버리지 개념과 적정 수준 이해
