# 아키텍처 설계 면접 질문 & 답변

## 사용 방법
1. 질문을 먼저 읽고 스스로 답변해보세요
2. 답변을 확인하고 부족한 부분을 학습하세요
3. ⭐ 표시는 빈출 질문입니다

---

## 시스템 설계 면접 접근법

```
1. 요구사항 명확화 (3-5분)
   - 기능 요구사항
   - 비기능 요구사항 (규모, 지연시간, 가용성)

2. 대략적 설계 (10분)
   - 핵심 컴포넌트 도식화
   - 데이터 흐름 설명

3. 상세 설계 (15분)
   - 핵심 컴포넌트 깊이 파고들기
   - 데이터베이스 스키마
   - API 설계

4. 확장성/가용성 논의 (10분)
   - 병목 지점 파악
   - 스케일링 전략
   - 장애 대응

5. 트레이드오프 설명
   - 선택의 이유
   - 대안과 비교
```

---

## Q1. URL 단축 서비스를 설계해주세요. ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 요구사항 정리

```
기능적 요구사항:
- 긴 URL → 짧은 URL 변환
- 짧은 URL 접속 시 원본으로 리다이렉트
- (선택) 커스텀 alias, 만료 시간

비기능적 요구사항:
- 월 1억 URL 생성 (쓰기)
- 월 100억 리다이렉트 (읽기) → 읽기:쓰기 = 100:1
- 가용성 99.9%
- 낮은 지연시간 (< 100ms)
```

### 대략적 설계

```
┌─────────────────────────────────────────────────────┐
│                    Client                            │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│                Load Balancer                         │
└──────────────────────┬──────────────────────────────┘
                       │
         ┌─────────────┴─────────────┐
         │                           │
┌────────▼────────┐       ┌─────────▼─────────┐
│  API Server     │       │   API Server      │
│  (URL 생성)     │       │   (리다이렉트)     │
└────────┬────────┘       └─────────┬─────────┘
         │                          │
         │         ┌────────────────┘
         │         │
┌────────▼─────────▼──────────────────────────────────┐
│                    Cache (Redis)                     │
│               (핫 데이터 캐싱)                        │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│              Database (NoSQL/RDB)                    │
│            short_url → long_url 매핑                 │
└─────────────────────────────────────────────────────┘
```

### Short URL 생성 방법

```
방법 1: Base62 인코딩
- 0-9, a-z, A-Z = 62 문자
- 7자리로 62^7 = 3.5조 URL 표현 가능

방법 2: Hash + 충돌 처리
- MD5/SHA 해시 후 앞 7자리 사용
- 충돌 시 suffix 추가

방법 3: Counter 기반
- 분산 ID 생성기 (Snowflake)
- ID를 Base62로 변환

선택: Counter 기반 (충돌 없음, 예측 가능)
```

### 데이터베이스 설계

```sql
-- URL 테이블
CREATE TABLE urls (
    id BIGINT PRIMARY KEY,
    short_code VARCHAR(10) UNIQUE,
    long_url TEXT NOT NULL,
    created_at TIMESTAMP,
    expires_at TIMESTAMP,
    click_count BIGINT DEFAULT 0,

    INDEX idx_short_code (short_code)
);

-- 규모: 1억 URL × 1KB = 100GB (충분히 단일 DB)
```

### 캐싱 전략

```
Redis 캐싱:
- 키: short_code
- 값: long_url
- TTL: 24시간
- 정책: Write-through

캐시 히트율 목표: 90%+
핫 URL이 대부분의 트래픽 차지
```

### 확장성 고려

```
읽기 확장:
- Read Replica
- Redis 클러스터
- CDN 엣지 캐싱

쓰기 확장:
- ID 생성기 분산 (Snowflake)
- 샤딩 (short_code 기반)

가용성:
- Multi-AZ 배포
- 자동 페일오버
```

</details>

---

## Q2. 실시간 채팅 시스템을 설계해주세요. ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 요구사항 정리

```
기능적 요구사항:
- 1:1 채팅
- 그룹 채팅 (최대 500명)
- 메시지 전송/수신
- 읽음 확인
- 오프라인 사용자 메시지 저장

비기능적 요구사항:
- DAU 1000만
- 지연시간 < 200ms
- 메시지 순서 보장
- 데이터 영속성
```

### 대략적 설계

```
┌─────────────────────────────────────────────────────┐
│                    Clients                           │
└────────────────────┬────────────────────────────────┘
                     │ WebSocket
┌────────────────────▼────────────────────────────────┐
│              WebSocket Gateway                       │
│         (연결 관리, 메시지 라우팅)                    │
└────────────────────┬────────────────────────────────┘
                     │
       ┌─────────────┴─────────────┐
       │                           │
┌──────▼──────┐             ┌──────▼──────┐
│  Message    │             │  Presence   │
│  Service    │             │  Service    │
│ (메시지처리) │             │ (온라인상태) │
└──────┬──────┘             └──────┬──────┘
       │                           │
       │         ┌─────────────────┘
       │         │
┌──────▼─────────▼────────────────────────────────────┐
│             Message Queue (Kafka)                    │
│            (메시지 순서 보장, 버퍼링)                 │
└──────────────────┬──────────────────────────────────┘
       │                           │
┌──────▼──────┐             ┌──────▼──────┐
│   Message   │             │   Redis     │
│   Storage   │             │  (Session,  │
│  (Cassandra)│             │   Presence) │
└─────────────┘             └─────────────┘
```

### 핵심 컴포넌트

```
1. WebSocket Gateway
   - 클라이언트 연결 관리
   - 연결당 서버 매핑 (Redis에 저장)
   - 메시지 라우팅

2. Message Service
   - 메시지 저장
   - 그룹 멤버십 관리
   - 읽음 확인 처리

3. Presence Service
   - 온라인/오프라인 상태
   - 마지막 접속 시간

4. Message Queue
   - 메시지 순서 보장
   - 부하 분산
   - 재처리 (실패 시)
```

### 메시지 전송 흐름

```
1:1 채팅:
┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐
│User A  │───▶│Gateway │───▶│ Kafka  │───▶│Gateway │───▶│User B│
│        │    │Server 1│    │        │    │Server 2│    │      │
└────────┘    └────────┘    └────────┘    └────────┘    └──────┘
                  │                           │
                  └───────────┬───────────────┘
                              ▼
                        ┌──────────┐
                        │ Cassandra│
                        │ (저장)   │
                        └──────────┘

그룹 채팅:
- 그룹 멤버 목록 조회
- 각 멤버의 Gateway 서버 확인
- 병렬로 메시지 전달
```

### 오프라인 메시지 처리

```
수신자가 오프라인:
1. Kafka에 메시지 저장
2. Cassandra에 영구 저장
3. 온라인 시 미수신 메시지 조회

푸시 알림:
- FCM/APNs 연동
- 오프라인 사용자에게 푸시
```

### 데이터베이스 설계

```
Cassandra (메시지 저장):
- 파티션 키: chat_room_id
- 클러스터링 키: message_id (시간순 정렬)
- 쓰기 최적화, 수평 확장 용이

Redis:
- 세션 관리 (user_id → server_id)
- 온라인 상태 (SET)
- 최근 메시지 캐시
```

</details>

---

## Q3. 알림 시스템을 설계해주세요. ⭐⭐

<details>
<summary>답변 보기</summary>

### 요구사항 정리

```
기능적 요구사항:
- 다양한 채널 (푸시, SMS, 이메일)
- 실시간 + 예약 발송
- 템플릿 기반 메시지
- 구독/수신거부 관리

비기능적 요구사항:
- 일 1억 알림 발송
- 높은 전송 성공률 (99%+)
- 중복 발송 방지
- 우선순위 처리
```

### 대략적 설계

```
┌─────────────────────────────────────────────────────┐
│              서비스들 (주문, 결제, 마케팅...)         │
└──────────────────────┬──────────────────────────────┘
                       │ API
┌──────────────────────▼──────────────────────────────┐
│              Notification Service                    │
│        (검증, 템플릿 처리, 큐 발행)                   │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│              Message Queue (Kafka)                   │
│         (priority별 토픽, 순서 보장)                  │
└──────────────────────┬──────────────────────────────┘
           ┌───────────┼───────────┐
           │           │           │
    ┌──────▼───┐ ┌─────▼────┐ ┌───▼──────┐
    │   Push   │ │   SMS    │ │  Email   │
    │  Worker  │ │  Worker  │ │  Worker  │
    │  (FCM)   │ │ (Twilio) │ │   (SES)  │
    └──────────┘ └──────────┘ └──────────┘
```

### 핵심 컴포넌트

```
1. Notification Service
   - 요청 검증
   - 사용자 선호도 확인
   - 템플릿 렌더링
   - 중복 체크 (idempotency key)

2. Rate Limiter
   - 채널별/사용자별 제한
   - 슬라이딩 윈도우

3. Priority Queue
   - 긴급: OTP, 결제 확인
   - 높음: 주문 알림
   - 보통: 마케팅

4. Worker Pool
   - 채널별 워커
   - 재시도 로직 (exponential backoff)
   - Dead Letter Queue
```

### 중복 발송 방지

```
방법 1: Idempotency Key
- 클라이언트가 고유 키 전송
- Redis로 24시간 중복 체크

방법 2: 데이터베이스 제약
- notification_id + channel UNIQUE

방법 3: 분산 락
- Redis SETNX
- 동일 알림 동시 처리 방지
```

### 재시도 전략

```
실패 시 재시도:
- 1차: 즉시
- 2차: 1분 후
- 3차: 5분 후
- 4차: 30분 후
- 최종 실패: DLQ 이동

재시도 대상:
- 네트워크 오류 → 재시도
- 유효하지 않은 토큰 → 토큰 삭제, 재시도 안함
- Rate limit → 백오프 후 재시도
```

### 모니터링 지표

```
- 발송 성공률 (채널별)
- 평균 지연시간
- 큐 적체량
- 재시도 비율
- 채널별 비용
```

</details>

---

## Q4. 파일 저장/공유 시스템을 설계해주세요. ⭐⭐

<details>
<summary>답변 보기</summary>

### 요구사항 정리

```
기능적 요구사항:
- 파일 업로드/다운로드
- 폴더 구조
- 파일 공유 (링크 생성)
- 버전 관리

비기능적 요구사항:
- 파일 크기: 최대 10GB
- 저장 용량: 사용자당 100GB
- 가용성: 99.99%
- 내구성: 99.999999999% (11 nines)
```

### 대략적 설계

```
┌─────────────────────────────────────────────────────┐
│                    Client                            │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│                  CDN (CloudFront)                    │
│              (다운로드 가속, 캐싱)                    │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│                 API Gateway                          │
└──────────────────────┬──────────────────────────────┘
           ┌───────────┴───────────┐
           │                       │
    ┌──────▼───────┐       ┌──────▼───────┐
    │  Metadata    │       │   Upload     │
    │   Service    │       │   Service    │
    └──────┬───────┘       └──────┬───────┘
           │                       │
    ┌──────▼───────┐       ┌──────▼───────┐
    │   MySQL      │       │     S3       │
    │  (메타데이터) │       │  (파일 저장)  │
    └──────────────┘       └──────────────┘
```

### 대용량 파일 업로드

```
Multipart Upload:
1. 클라이언트가 업로드 시작 요청
2. 서버가 upload_id 발급
3. 파일을 청크로 분할 (5MB 단위)
4. 각 청크 병렬 업로드
5. 모든 청크 완료 후 병합 요청

┌─────────┐     ┌─────────┐     ┌─────────┐
│ Chunk 1 │────▶│         │     │         │
├─────────┤     │         │     │   S3    │
│ Chunk 2 │────▶│ Upload  │────▶│  Final  │
├─────────┤     │ Service │     │  File   │
│ Chunk 3 │────▶│         │     │         │
└─────────┘     └─────────┘     └─────────┘

장점:
- 네트워크 실패 시 해당 청크만 재전송
- 병렬 업로드로 속도 향상
- 중간 상태 저장 가능
```

### 메타데이터 설계

```sql
-- 파일 테이블
CREATE TABLE files (
    id BIGINT PRIMARY KEY,
    user_id BIGINT,
    parent_folder_id BIGINT,
    name VARCHAR(255),
    size BIGINT,
    s3_key VARCHAR(512),
    version INT DEFAULT 1,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,

    INDEX idx_user_folder (user_id, parent_folder_id)
);

-- 공유 링크 테이블
CREATE TABLE share_links (
    id BIGINT PRIMARY KEY,
    file_id BIGINT,
    token VARCHAR(64) UNIQUE,
    expires_at TIMESTAMP,
    download_count INT DEFAULT 0,
    max_downloads INT
);
```

### 동기화 처리

```
변경 감지:
1. 로컬 파일 해시 계산
2. 서버와 비교
3. 변경분만 동기화

충돌 해결:
- 마지막 쓰기 승리 (Last Write Wins)
- 또는 충돌 버전 둘 다 보관
```

### 확장성 고려

```
저장소:
- S3 Standard: 자주 접근
- S3 Glacier: 오래된 버전

메타데이터:
- 읽기: Read Replica
- 쓰기: 샤딩 (user_id 기반)

가용성:
- S3: 자체 11 nines 내구성
- Multi-AZ 데이터베이스
- CDN 엣지 캐싱
```

</details>

---

## Q5. 검색 시스템을 설계해주세요. ⭐⭐

<details>
<summary>답변 보기</summary>

### 요구사항 정리

```
기능적 요구사항:
- 키워드 검색
- 자동완성
- 필터링 (카테고리, 가격, 날짜)
- 정렬 (관련도, 인기도, 최신순)

비기능적 요구사항:
- 문서 수: 1억 개
- QPS: 10,000
- 지연시간: < 200ms
- 가용성: 99.9%
```

### 대략적 설계

```
┌─────────────────────────────────────────────────────┐
│                    Client                            │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│                 API Gateway                          │
│              (Rate Limiting, 캐싱)                   │
└──────────────────────┬──────────────────────────────┘
                       │
         ┌─────────────┴─────────────┐
         │                           │
┌────────▼────────┐       ┌─────────▼─────────┐
│  Search Service │       │   Autocomplete    │
│  (검색 처리)    │       │    Service        │
└────────┬────────┘       └─────────┬─────────┘
         │                          │
         │         ┌────────────────┤
         │         │                │
┌────────▼─────────▼──────┐  ┌─────▼──────┐
│   Elasticsearch         │  │   Redis    │
│   (역인덱스, 검색)       │  │ (자동완성) │
└─────────────────────────┘  └────────────┘
```

### Elasticsearch 인덱스 설계

```json
{
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "analyzer": "korean",
        "fields": {
          "keyword": { "type": "keyword" }
        }
      },
      "content": {
        "type": "text",
        "analyzer": "korean"
      },
      "category": { "type": "keyword" },
      "price": { "type": "integer" },
      "created_at": { "type": "date" },
      "popularity_score": { "type": "float" }
    }
  },
  "settings": {
    "number_of_shards": 5,
    "number_of_replicas": 1
  }
}
```

### 자동완성 구현

```
방법 1: Elasticsearch Completion Suggester
- 전용 자료구조 (FST)
- 빠른 prefix 검색

방법 2: Redis + Trie
- 인기 검색어 캐싱
- TTL로 최신성 유지

방법 3: 혼합
- Top N: Redis (캐시 히트)
- 나머지: ES completion
```

### 검색 랭킹

```
점수 계산:
score = TF-IDF × boost × popularity × freshness

TF-IDF: 텍스트 관련도
boost: 필드별 가중치 (제목 > 본문)
popularity: 클릭수, 구매수
freshness: 최신 컨텐츠 가산점

예시 쿼리:
{
  "query": {
    "function_score": {
      "query": { "match": { "title": "검색어" } },
      "functions": [
        {
          "field_value_factor": {
            "field": "popularity_score",
            "modifier": "log1p"
          }
        },
        {
          "gauss": {
            "created_at": {
              "origin": "now",
              "scale": "7d"
            }
          }
        }
      ]
    }
  }
}
```

### 확장성

```
Elasticsearch 클러스터:
- 5 샤드 × 2 레플리카
- 샤드당 10GB 권장
- 노드 추가로 수평 확장

캐싱:
- 인기 검색어 결과 캐싱
- CDN 엣지 캐싱 (정적 결과)

인덱싱:
- Kafka로 변경 이벤트 수집
- 배치 + 실시간 인덱싱 병행
```

</details>

---

## 학습 체크리스트

- [ ] URL 단축 서비스 설계 설명 가능
- [ ] 실시간 채팅 시스템 설계 설명 가능
- [ ] 알림 시스템 설계 설명 가능
- [ ] 파일 저장 시스템 설계 설명 가능
- [ ] 검색 시스템 설계 설명 가능
- [ ] 각 시스템의 트레이드오프 설명 가능
