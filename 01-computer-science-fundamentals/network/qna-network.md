# 네트워크 면접 질문 & 답변

## 사용 방법
1. 질문을 먼저 읽고 스스로 답변해보세요
2. 답변을 확인하고 부족한 부분을 학습하세요
3. ⭐ 표시는 빈출 질문입니다

---

## Q1. TCP와 UDP의 차이점을 설명해주세요. ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
TCP는 연결 지향적 프로토콜로 신뢰성을 보장하고, UDP는 비연결 지향적 프로토콜로 속도를 우선시합니다.

### 비교 표

| 구분 | TCP | UDP |
|------|-----|-----|
| 연결 방식 | 연결 지향 (3-way handshake) | 비연결 지향 |
| 신뢰성 | 보장 (재전송, 순서 보장) | 미보장 |
| 속도 | 상대적으로 느림 | 빠름 |
| 헤더 크기 | 20바이트 | 8바이트 |
| 흐름 제어 | 있음 | 없음 |
| 사용 사례 | HTTP, FTP, 이메일 | 스트리밍, DNS, 게임 |

### 면접관이 주목하는 포인트
- 신뢰성 보장 메커니즘 설명 (ACK, 재전송)
- 실제 사용 사례와 선택 기준

### 꼬리 질문 대비
- "HTTP/3는 왜 UDP(QUIC)를 사용하나요?"
  → 연결 설정 비용 감소, Head-of-line blocking 해결

</details>

---

## Q2. HTTP와 HTTPS의 차이점은 무엇인가요? ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
HTTPS는 HTTP에 SSL/TLS 암호화를 추가한 프로토콜입니다. 데이터가 암호화되어 전송되므로 도청, 변조, 위장을 방지할 수 있습니다.

### 비교

| 구분 | HTTP | HTTPS |
|------|------|-------|
| 포트 | 80 | 443 |
| 암호화 | 없음 | SSL/TLS |
| 보안 | 취약 | 안전 |
| 인증서 | 불필요 | 필요 |
| 속도 | 빠름 | 약간 느림 (핸드셰이크) |

### SSL/TLS 핸드셰이크 과정 (간략)
1. Client Hello: 지원하는 암호화 방식 전송
2. Server Hello: 선택된 암호화 방식 + 인증서 전송
3. 키 교환: 대칭키 생성 및 공유
4. 암호화 통신 시작

### 면접관이 주목하는 포인트
- 대칭키/비대칭키 암호화 차이
- 왜 두 가지를 함께 사용하는지

### 꼬리 질문 대비
- "왜 대칭키와 비대칭키를 함께 사용하나요?"
  → 비대칭키로 대칭키를 안전하게 교환, 이후 빠른 대칭키로 통신

</details>

---

## Q3. 3-way Handshake와 4-way Handshake를 설명해주세요. ⭐⭐

<details>
<summary>답변 보기</summary>

### 3-way Handshake (연결 수립)
```
Client              Server
  │                   │
  │──── SYN ─────────►│  1. 연결 요청
  │                   │
  │◄─── SYN + ACK ────│  2. 요청 수락 + 확인
  │                   │
  │──── ACK ─────────►│  3. 연결 확립
  │                   │
```

### 4-way Handshake (연결 종료)
```
Client              Server
  │                   │
  │──── FIN ─────────►│  1. 종료 요청
  │                   │
  │◄─── ACK ─────────│  2. 확인
  │                   │
  │◄─── FIN ─────────│  3. 서버도 종료 준비 완료
  │                   │
  │──── ACK ─────────►│  4. 확인, 연결 종료
  │                   │
```

### 면접관이 주목하는 포인트
- 왜 3단계/4단계가 필요한지
- TIME_WAIT 상태의 역할

### 꼬리 질문 대비
- "왜 연결 종료는 4단계인가요?"
  → 서버가 남은 데이터를 전송할 시간이 필요하기 때문
- "TIME_WAIT 상태는 왜 필요한가요?"
  → 지연된 패킷 처리, ACK 손실 시 재전송 대비

</details>

---

## Q4. 주소창에 URL을 입력하면 무슨 일이 일어나나요? ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변 (단계별)

1. **URL 파싱**: 프로토콜, 도메인, 경로 분리
2. **DNS 조회**: 도메인 → IP 주소 변환
3. **TCP 연결**: 3-way Handshake
4. **TLS 핸드셰이크**: HTTPS인 경우
5. **HTTP 요청**: GET /path HTTP/1.1
6. **서버 처리**: 요청 처리, 응답 생성
7. **HTTP 응답**: HTML, CSS, JS 등 전송
8. **브라우저 렌더링**: DOM 파싱, CSSOM, 렌더 트리

### DNS 조회 과정
```
브라우저 캐시 → OS 캐시 → 라우터 캐시 → ISP DNS →
Root DNS → TLD DNS → 권한 있는 DNS
```

### 면접관이 주목하는 포인트
- 각 단계에서의 캐싱 전략
- 성능 최적화 포인트

### 꼬리 질문 대비
- "DNS 조회를 최적화하는 방법은?"
  → DNS Prefetch, CDN 사용

</details>

---

## Q5. REST API란 무엇인가요? ⭐⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
REST는 HTTP를 기반으로 자원을 이름으로 구분하여 상태를 주고받는 아키텍처 스타일입니다.

### REST 6가지 원칙
1. **Client-Server**: 클라이언트와 서버 분리
2. **Stateless**: 서버는 클라이언트 상태 저장 안 함
3. **Cacheable**: 응답은 캐시 가능해야 함
4. **Uniform Interface**: 일관된 인터페이스
5. **Layered System**: 계층화된 시스템
6. **Code on Demand** (선택): 서버에서 코드 전송 가능

### HTTP 메서드와 CRUD

| 메서드 | 동작 | 멱등성 |
|--------|------|--------|
| GET | 조회 | O |
| POST | 생성 | X |
| PUT | 전체 수정 | O |
| PATCH | 부분 수정 | X |
| DELETE | 삭제 | O |

### 면접관이 주목하는 포인트
- RESTful한 URL 설계
- 상태 코드 활용 (200, 201, 400, 401, 404, 500)

### 꼬리 질문 대비
- "PUT과 PATCH의 차이점은?"
  → PUT은 전체 리소스 교체, PATCH는 부분 수정
- "멱등성이란?"
  → 같은 요청을 여러 번 해도 결과가 동일

</details>

---

## Q6. OSI 7계층을 설명해주세요. ⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변

| 계층 | 이름 | 역할 | 프로토콜/장비 |
|------|------|------|-------------|
| 7 | 응용 | 사용자 인터페이스 | HTTP, FTP |
| 6 | 표현 | 데이터 변환, 암호화 | SSL, JPEG |
| 5 | 세션 | 연결 관리 | NetBIOS |
| 4 | 전송 | 포트, 신뢰성 | TCP, UDP |
| 3 | 네트워크 | IP 주소, 라우팅 | IP, 라우터 |
| 2 | 데이터링크 | MAC 주소, 프레임 | 이더넷, 스위치 |
| 1 | 물리 | 비트 전송 | 케이블, 허브 |

### TCP/IP 4계층과 매핑
- 응용 (7,6,5) → Application
- 전송 (4) → Transport
- 네트워크 (3) → Internet
- 데이터링크+물리 (2,1) → Network Access

### 면접관이 주목하는 포인트
- 각 계층의 핵심 역할
- 실무와의 연관성 (HTTP는 7계층, TCP는 4계층)

</details>

---

## Q7. CORS란 무엇이며 왜 필요한가요? ⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변
CORS(Cross-Origin Resource Sharing)는 다른 출처(Origin)의 리소스에 접근할 수 있게 해주는 메커니즘입니다. 브라우저의 동일 출처 정책(SOP)을 완화하기 위해 사용됩니다.

### 동일 출처 판단 기준
`프로토콜 + 호스트 + 포트`가 모두 같아야 동일 출처

### CORS 해결 방법
1. 서버에서 Access-Control-Allow-Origin 헤더 설정
2. 프록시 서버 사용
3. JSONP (구식)

### Preflight 요청
- OPTIONS 메서드로 사전 검사
- 단순 요청이 아닌 경우 발생

### 면접관이 주목하는 포인트
- SOP가 왜 필요한지 (보안)
- 실무에서의 해결 경험

</details>

---

## Q8. 쿠키와 세션의 차이점은? ⭐⭐

<details>
<summary>답변 보기</summary>

### 핵심 답변

| 구분 | 쿠키 | 세션 |
|------|------|------|
| 저장 위치 | 클라이언트 | 서버 |
| 보안 | 취약 | 비교적 안전 |
| 용량 | 4KB 제한 | 서버 메모리 |
| 만료 | 설정 가능 | 브라우저 종료 시 |

### 세션 동작 방식
1. 서버에서 세션 ID 생성
2. 세션 ID를 쿠키로 클라이언트에 전달
3. 이후 요청 시 쿠키의 세션 ID로 사용자 식별

### 면접관이 주목하는 포인트
- 스케일아웃 시 세션 관리 문제
- JWT와의 비교

### 꼬리 질문 대비
- "서버 증설 시 세션 관리는 어떻게?"
  → Sticky Session, Session Clustering, Redis 세션 스토어

</details>

---

## 학습 체크리스트

- [ ] TCP vs UDP 차이 설명 가능
- [ ] HTTP vs HTTPS 차이 설명 가능
- [ ] 3-way/4-way Handshake 설명 가능
- [ ] URL 입력 시 발생하는 과정 설명 가능
- [ ] REST API 원칙 설명 가능
- [ ] CORS 개념과 해결 방법 이해
